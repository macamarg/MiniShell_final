Starting minishell tests...

[1;34m=== Testing Environment Path ===[0m

Testing:         ls
[31mKO: [0m         ls
Bash output:
bash_output.txt
expander_tester.sh
libft
Makefile
minishell
minishell.h
minishell_teste.log
obj
readline.supp
README.md
src
updated_tester.sh
Minishell output:
bash_output.txt
expander_tester.sh
libft
Makefile
obj
readline.supp
README.md
src
updated_tester.sh

Testing:         unset PATH
[32mOK[0m

Testing:         ls
[31mKO: [0m         ls
Bash output:
bash_output.txt
diff_output.txt
expander_tester.sh
libft
Makefile
minishell
minishell.h
minishell_output.txt
minishell_teste.log
obj
readline.supp
README.md
src
updated_tester.sh
Minishell output:
bash_output.txt
diff_output.txt
expander_tester.sh
libft
Makefile
obj
readline.supp
README.md
src
updated_tester.sh

Testing:         export PATH=/bin:/usr/bin
[32mOK[0m

Testing:         ls
[31mKO: [0m         ls
Bash output:
bash_output.txt
diff_output.txt
expander_tester.sh
libft
Makefile
minishell
minishell.h
minishell_output.txt
minishell_teste.log
obj
readline.supp
README.md
src
updated_tester.sh
Minishell output:
bash_output.txt
diff_output.txt
expander_tester.sh
libft
Makefile
obj
readline.supp
README.md
src
updated_tester.sh

Testing:     
[32mOK[0m

[1;34m=== Testing Single Quotes ===[0m

Testing:         echo 'mcmarqs'
[32mOK[0m

Testing:         echo 'Hello   World'
[32mOK[0m

Testing:     
[32mOK[0m

[1;34m=== Testing env ===[0m

Testing:         env
[31mKO: [0m         env
Bash output:
SHELL=/bin/bash
SESSION_MANAGER=local/mcmarqs-desk:@/tmp/.ICE-unix/3437,unix/mcmarqs-desk:/tmp/.ICE-unix/3437
WINDOWID=75497475
QT_ACCESSIBILITY=1
COLORTERM=truecolor
XDG_CONFIG_DIRS=/etc/xdg
XDG_SESSION_PATH=/org/freedesktop/DisplayManager/Session0
XDG_MENU_PREFIX=xfce-
QT_LOGGING_RULES=qt.qpa.xcb.warning=false
SSH_AUTH_SOCK=/tmp/ssh-gQKXzb26RR9C/agent.3437
XDG_CONFIG_HOME=/home/mcmarqs/.config
DESKTOP_SESSION=xfce
SSH_AGENT_PID=3548
GTK_MODULES=canberra-gtk-module:gail:atk-bridge
XDG_SEAT=seat0
PWD=/home/mcmarqs/git/MiniShell_final
LOGNAME=mcmarqs
XDG_SESSION_DESKTOP=xfce
QT_QPA_PLATFORMTHEME=gtk2
XDG_SESSION_TYPE=x11
_=/usr/bin/env
XAUTHORITY=/home/mcmarqs/.Xauthority
XDG_GREETER_DATA_DIR=/var/lib/lightdm/data/mcmarqs
GDM_LANG=pt_BR.UTF-8
HOME=/home/mcmarqs
LANG=pt_BR.UTF-8
LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=00:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.avif=01;35:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.webp=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:*~=00;90:*#=00;90:*.bak=00;90:*.old=00;90:*.orig=00;90:*.part=00;90:*.rej=00;90:*.swp=00;90:*.tmp=00;90:*.dpkg-dist=00;90:*.dpkg-old=00;90:*.ucf-dist=00;90:*.ucf-new=00;90:*.ucf-old=00;90:*.rpmnew=00;90:*.rpmorig=00;90:*.rpmsave=00;90:
XDG_CURRENT_DESKTOP=XFCE
VTE_VERSION=7006
QT_PLATFORMTHEME=gtk2
XDG_SEAT_PATH=/org/freedesktop/DisplayManager/Seat0
XDG_CACHE_HOME=/home/mcmarqs/.cache
XDG_SESSION_CLASS=user
TERM=xterm-256color
USER=mcmarqs
DISPLAY=:0.0
SHLVL=3
XDG_VTNR=7
XDG_SESSION_ID=1
PAPERSIZE=a4
XDG_RUNTIME_DIR=/run/user/1000
QT_PLATFORM_PLUGIN=gtk2
XDG_DATA_DIRS=/usr/share/xfce4:/home/mcmarqs/.local/share/flatpak/exports/share:/var/lib/flatpak/exports/share:/usr/local/share:/usr/share
PATH=/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games:/sbin:/usr/sbin
GDMSESSION=xfce
DBUS_SESSION_BUS_ADDRESS=unix:path=/tmp/dbus-RVDkFgatNG,guid=24de08ad83b3647e549288b067d19212
QT_SCALE_FACTOR=1
OLDPWD=/home/mcmarqs/git
Minishell output:
SHELL=/bin/bash
SESSION_MANAGER=local/mcmarqs-desk:@/tmp/.ICE-unix/3437,unix/mcmarqs-desk:/tmp/.ICE-unix/3437
WINDOWID=75497475
QT_ACCESSIBILITY=1
COLORTERM=truecolor
XDG_CONFIG_DIRS=/etc/xdg
XDG_SESSION_PATH=/org/freedesktop/DisplayManager/Session0
XDG_MENU_PREFIX=xfce-
QT_LOGGING_RULES=qt.qpa.xcb.warning=false
SSH_AUTH_SOCK=/tmp/ssh-gQKXzb26RR9C/agent.3437
XDG_CONFIG_HOME=/home/mcmarqs/.config
DESKTOP_SESSION=xfce
SSH_AGENT_PID=3548
GTK_MODULES=canberra-gtk-module:gail:atk-bridge
XDG_SEAT=seat0
PWD=/home/mcmarqs/git/MiniShell_final
XDG_SESSION_DESKTOP=xfce
LOGNAME=mcmarqs
QT_QPA_PLATFORMTHEME=gtk2
XDG_SESSION_TYPE=x11
XAUTHORITY=/home/mcmarqs/.Xauthority
XDG_GREETER_DATA_DIR=/var/lib/lightdm/data/mcmarqs
GDM_LANG=pt_BR.UTF-8
HOME=/home/mcmarqs
LANG=pt_BR.UTF-8
LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=00:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.avif=01;35:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.webp=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:*~=00;90:*#=00;90:*.bak=00;90:*.old=00;90:*.orig=00;90:*.part=00;90:*.rej=00;90:*.swp=00;90:*.tmp=00;90:*.dpkg-dist=00;90:*.dpkg-old=00;90:*.ucf-dist=00;90:*.ucf-new=00;90:*.ucf-old=00;90:*.rpmnew=00;90:*.rpmorig=00;90:*.rpmsave=00;90:
XDG_CURRENT_DESKTOP=XFCE
VTE_VERSION=7006
QT_PLATFORMTHEME=gtk2
XDG_SEAT_PATH=/org/freedesktop/DisplayManager/Seat0
XDG_CACHE_HOME=/home/mcmarqs/.cache
XDG_SESSION_CLASS=user
TERM=xterm-256color
USER=mcmarqs
DISPLAY=:0.0
SHLVL=2
XDG_VTNR=7
XDG_SESSION_ID=1
PAPERSIZE=a4
XDG_RUNTIME_DIR=/run/user/1000
QT_PLATFORM_PLUGIN=gtk2
XDG_DATA_DIRS=/usr/share/xfce4:/home/mcmarqs/.local/share/flatpak/exports/share:/var/lib/flatpak/exports/share:/usr/local/share:/usr/share
PATH=/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games:/sbin:/usr/sbin
GDMSESSION=xfce
DBUS_SESSION_BUS_ADDRESS=unix:path=/tmp/dbus-RVDkFgatNG,guid=24de08ad83b3647e549288b067d19212
QT_SCALE_FACTOR=1
OLDPWD=/home/mcmarqs/git

Testing:     
[32mOK[0m

[1;34m=== Testing unset ===[0m

Testing:         unset MY_VAR
[32mOK[0m

Testing:         env | grep MY_VAR
[32mOK[0m

Testing:     
[32mOK[0m

[1;34m=== Testing pwd ===[0m

Testing:         pwd
[32mOK[0m

Testing:     
[32mOK[0m

[1;34m=== Testing Pipes ===[0m

Testing:         cat Makefile | grep minishell | wc -l
[32mOK[0m

Testing:         cat Makefile | grep minishell > output.txt
[32mOK[0m

Testing:     
[32mOK[0m

[1;34m=== Testing echo ===[0m

Testing:         echo
[32mOK[0m

Testing:         echo Hello World
[32mOK[0m

Testing:         echo -n Hello World
[31mKO: [0m         echo -n Hello World
Bash output:
Hello WorldMinishell output:

Testing:         echo "Hello   World"
[32mOK[0m

Testing:         echo "cat file.txt | grep something"
[32mOK[0m

Testing:         echo 'mcmarqs'
[32mOK[0m

Testing:         echo 'Hello   World'
[32mOK[0m

Testing:         echo teste"     "teste
[32mOK[0m

Testing:         echo teste"''"'""'teste
[32mOK[0m

Testing:     
[32mOK[0m

[1;34m=== Testing Redirection ===[0m

Testing:         cat < Makefile
[31mKO: [0m         cat < Makefile
Bash output:
NAME = minishell

SRC_DIR = ./src

OBJ_DIR = ./obj

LIBFT = libft/libft.a

LIBFT_FLAGS = -Llibft -lft

SRC = $(SRC_DIR)/minishell_main.c\
	$(SRC_DIR)/minishell_readline.c\
	$(SRC_DIR)/minishell_parse.c\
	$(SRC_DIR)/minishell_call.c\
	$(SRC_DIR)/minishell_tokenlst.c\
	$(SRC_DIR)/minishell_classtoken.c\
	$(SRC_DIR)/minishell_exptoken.c\
	$(SRC_DIR)/print_tokenlst.c\
	$(SRC_DIR)/minishell_cmdstruc.c\
	$(SRC_DIR)/minishell_cmd_utils.c\
	$(SRC_DIR)/minishell_pathfill.c\
	$(SRC_DIR)/minishell_expand.c\
	$(SRC_DIR)/minishell_expandutils.c\
	$(SRC_DIR)/minishell_redir.c\
	$(SRC_DIR)/minishell_cpy_envp.c\
	$(SRC_DIR)/minishell_exec.c\
	$(SRC_DIR)/exec_get_path.c\
	$(SRC_DIR)/exec_get_path_utils.c\
	$(SRC_DIR)/exec_builtin.c\
	$(SRC_DIR)/builtin_pwd.c\
	$(SRC_DIR)/builtin_echo.c\
	$(SRC_DIR)/builtin_cd.c\
	$(SRC_DIR)/builtin_env.c\
	$(SRC_DIR)/builtin_unset.c\
	$(SRC_DIR)/builtin_export.c\
	$(SRC_DIR)/builtin_export_utils.c\
	$(SRC_DIR)/builtin_exit.c\
	$(SRC_DIR)/heredoc.c\
	$(SRC_DIR)/sort_env.c\
	$(SRC_DIR)/exec_other.c\
	$(SRC_DIR)/exec_pipeline.c\
	$(SRC_DIR)/exec_pipeline_utils.c\
	$(SRC_DIR)/shell_level.c\
	$(SRC_DIR)/minishell_clean.c\
	$(SRC_DIR)/minishell_free.c\
	$(SRC_DIR)/test.c\
	$(SRC_DIR)/print_tokenlst.c\
	$(SRC_DIR)/minishell_signals.c\
	$(SRC_DIR)/minishell_signhadle.c\

OBJ = $(SRC:$(SRC_DIR)/%.c=$(OBJ_DIR)/%.o)

#DEP = $(OBJ:.o=.d)

WFLAGS = -Wall -Wextra -Werror

OPT = -g

CC = gcc
#TODO gcc - cc because windows
#-pthread => copile with POSIX threads library

.PHONY: all bonus clean fclean re valgrind

all: $(NAME)

$(NAME): $(OBJ)
	@$(CC) $(WFLAGS) $(LIBFT_FLAGS) $(OPT) $^ $(LIBFT) -lreadline -lncurses -o $@
	@echo "Compilation finished! Executable '$(NAME)' is ready."

libft/libft.a:
	@$(MAKE) -C libft

$(OBJ_DIR)/%.o: $(SRC_DIR)/%.c
	@mkdir -p $(OBJ_DIR)
	@$(CC) $(FLAGS) -c $< -o $@

#-MMD includes all #include dependencies but excludes system headers.

# Include dependencies
#-include $(DEP)

clean:
	@rm -f $(OBJ)
	@rm -rf $(OBJ_DIR)
	@echo "*.o were cleaned."

fclean: clean
	@rm -f $(NAME)
	@echo "Executable '$(NAME)' was removed."

re: fclean all

valgrind:
	valgrind --leak-check=full --show-leak-kinds=all --suppressions=readline.supp --track-fds=yes ./$(NAME)Minishell output:

SRC_DIR = ./src

OBJ_DIR = ./obj

LIBFT = libft/libft.a

LIBFT_FLAGS = -Llibft -lft

	$(SRC_DIR)/print_tokenlst.c\
	$(SRC_DIR)/exec_get_path.c\
	$(SRC_DIR)/exec_get_path_utils.c\
	$(SRC_DIR)/exec_builtin.c\
	$(SRC_DIR)/builtin_pwd.c\
	$(SRC_DIR)/builtin_echo.c\
	$(SRC_DIR)/builtin_cd.c\
	$(SRC_DIR)/builtin_env.c\
	$(SRC_DIR)/builtin_unset.c\
	$(SRC_DIR)/builtin_export.c\
	$(SRC_DIR)/builtin_export_utils.c\
	$(SRC_DIR)/builtin_exit.c\
	$(SRC_DIR)/heredoc.c\
	$(SRC_DIR)/sort_env.c\
	$(SRC_DIR)/exec_other.c\
	$(SRC_DIR)/exec_pipeline.c\
	$(SRC_DIR)/exec_pipeline_utils.c\
	$(SRC_DIR)/test.c\
	$(SRC_DIR)/print_tokenlst.c\

OBJ = $(SRC:$(SRC_DIR)/%.c=$(OBJ_DIR)/%.o)

#DEP = $(OBJ:.o=.d)

WFLAGS = -Wall -Wextra -Werror

OPT = -g

CC = gcc
#TODO gcc - cc because windows
#-pthread => copile with POSIX threads library

.PHONY: all bonus clean fclean re valgrind

all: $(NAME)

$(NAME): $(OBJ)
	@$(CC) $(WFLAGS) $(LIBFT_FLAGS) $(OPT) $^ $(LIBFT) -lreadline -lncurses -o $@
	@echo "Compilation finished! Executable '$(NAME)' is ready."

libft/libft.a:
	@$(MAKE) -C libft

$(OBJ_DIR)/%.o: $(SRC_DIR)/%.c
	@mkdir -p $(OBJ_DIR)
	@$(CC) $(FLAGS) -c $< -o $@

#-MMD includes all #include dependencies but excludes system headers.

# Include dependencies
#-include $(DEP)

clean:
	@rm -f $(OBJ)
	@rm -rf $(OBJ_DIR)
	@echo "*.o were cleaned."

fclean: clean
	@rm -f $(NAME)
	@echo "Executable '$(NAME)' was removed."

re: fclean all

valgrind:

Testing:         echo Hello > output.txt
[32mOK[0m

Testing:         cat <output.txt
[32mOK[0m

Testing:         rm output.txt
[32mOK[0m

Testing:         echo World >> output.txt
[32mOK[0m

Testing:         cat <output.txt
[32mOK[0m

Testing:         rm output.txt
[32mOK[0m

Testing:     
[32mOK[0m

[1;34m=== Testing Simple Commands ===[0m

Testing:         /bin/ls
[31mKO: [0m         /bin/ls
Bash output:
bash_output.txt
diff_output.txt
expander_tester.sh
libft
Makefile
minishell
minishell.h
minishell_output.txt
minishell_teste.log
obj
readline.supp
README.md
src
updated_tester.sh
Minishell output:
bash_output.txt
diff_output.txt
expander_tester.sh
libft
Makefile
obj
readline.supp
README.md
src
updated_tester.sh

Testing:         

[32mOK[0m

Testing:         ' '
[31mKO: [0m         ' '
Bash output:
bash: linha 1:  : comando não encontrado
Minishell output:

Testing:         /bin/ls -l
[31mKO: [0m         /bin/ls -l
Bash output:
total 132
-rw-r--r-- 1 mcmarqs mcmarqs     0 mar 13 10:01 bash_output.txt
-rw-r--r-- 1 mcmarqs mcmarqs    48 mar 13 10:01 diff_output.txt
-rwxr-xr-x 1 mcmarqs mcmarqs  4134 mar 12 16:23 expander_tester.sh
drwxr-xr-x 2 mcmarqs mcmarqs  4096 mar  2 15:16 libft
-rw-r--r-- 1 mcmarqs mcmarqs  2216 mar 12 14:02 Makefile
-rwxr-xr-x 1 mcmarqs mcmarqs 62512 mar 13 09:35 minishell
-rw-r--r-- 1 mcmarqs mcmarqs  6587 mar 12 16:59 minishell.h
-rw-r--r-- 1 mcmarqs mcmarqs     0 mar 13 10:01 minishell_output.txt
-rw-r--r-- 1 mcmarqs mcmarqs 13793 mar 13 10:01 minishell_teste.log
drwxr-xr-x 2 mcmarqs mcmarqs  4096 mar 13 09:35 obj
-rw-r--r-- 1 mcmarqs mcmarqs    85 mar  4 17:55 readline.supp
-rw-r--r-- 1 mcmarqs mcmarqs  4225 mar  2 15:16 README.md
drwxr-xr-x 2 mcmarqs mcmarqs  4096 mar 12 17:04 src
-rwxr-xr-x 1 mcmarqs mcmarqs  3298 mar 13 09:58 updated_tester.sh
Minishell output:
total 136
-rw-r--r-- 1 mcmarqs mcmarqs   861 mar 13 10:01 bash_output.txt
-rw-r--r-- 1 mcmarqs mcmarqs    48 mar 13 10:01 diff_output.txt
-rwxr-xr-x 1 mcmarqs mcmarqs  4134 mar 12 16:23 expander_tester.sh
drwxr-xr-x 2 mcmarqs mcmarqs  4096 mar  2 15:16 libft
-rw-r--r-- 1 mcmarqs mcmarqs  2216 mar 12 14:02 Makefile
drwxr-xr-x 2 mcmarqs mcmarqs  4096 mar 13 09:35 obj
-rw-r--r-- 1 mcmarqs mcmarqs    85 mar  4 17:55 readline.supp
-rw-r--r-- 1 mcmarqs mcmarqs  4225 mar  2 15:16 README.md
drwxr-xr-x 2 mcmarqs mcmarqs  4096 mar 12 17:04 src
-rwxr-xr-x 1 mcmarqs mcmarqs  3298 mar 13 09:58 updated_tester.sh

Testing:         /bin/echo Hello World
[32mOK[0m

Testing:         /bin/cat file.txt
[31mKO: [0m         /bin/cat file.txt
Bash output:
/bin/cat: file.txt: Arquivo ou diretório inexistente
Minishell output:

Testing:     
[32mOK[0m

[1;34m=== Testing cd ===[0m

Testing:         cd /tmp
[32mOK[0m

Testing:         pwd
[32mOK[0m

Testing:         cd ..
[32mOK[0m

Testing:         pwd
[32mOK[0m

Testing:     
[32mOK[0m

[1;34m=== Testing Return Value ===[0m

Testing:         /bin/ls
[31mKO: [0m         /bin/ls
Bash output:
bash_output.txt
diff_output.txt
expander_tester.sh
libft
Makefile
minishell
minishell.h
minishell_output.txt
minishell_teste.log
obj
readline.supp
README.md
src
updated_tester.sh
Minishell output:
bash_output.txt
diff_output.txt
expander_tester.sh
libft
Makefile
obj
readline.supp
README.md
src
updated_tester.sh

Testing:         echo 0
[32mOK[0m

Testing:         /bin/ls nonexistentfile
[31mKO: [0m         /bin/ls nonexistentfile
Bash output:
/bin/ls: não foi possível acessar 'nonexistentfile': Arquivo ou diretório inexistente
Minishell output:

Testing:         echo 0
[32mOK[0m

Testing:         expr 0 + 0
[32mOK[0m

Testing:     
[32mOK[0m

[1;34m=== Testing Relative Path ===[0m

Testing:         cat ./Makefile
[31mKO: [0m         cat ./Makefile
Bash output:
NAME = minishell

SRC_DIR = ./src

OBJ_DIR = ./obj

LIBFT = libft/libft.a

LIBFT_FLAGS = -Llibft -lft

SRC = $(SRC_DIR)/minishell_main.c\
	$(SRC_DIR)/minishell_readline.c\
	$(SRC_DIR)/minishell_parse.c\
	$(SRC_DIR)/minishell_call.c\
	$(SRC_DIR)/minishell_tokenlst.c\
	$(SRC_DIR)/minishell_classtoken.c\
	$(SRC_DIR)/minishell_exptoken.c\
	$(SRC_DIR)/print_tokenlst.c\
	$(SRC_DIR)/minishell_cmdstruc.c\
	$(SRC_DIR)/minishell_cmd_utils.c\
	$(SRC_DIR)/minishell_pathfill.c\
	$(SRC_DIR)/minishell_expand.c\
	$(SRC_DIR)/minishell_expandutils.c\
	$(SRC_DIR)/minishell_redir.c\
	$(SRC_DIR)/minishell_cpy_envp.c\
	$(SRC_DIR)/minishell_exec.c\
	$(SRC_DIR)/exec_get_path.c\
	$(SRC_DIR)/exec_get_path_utils.c\
	$(SRC_DIR)/exec_builtin.c\
	$(SRC_DIR)/builtin_pwd.c\
	$(SRC_DIR)/builtin_echo.c\
	$(SRC_DIR)/builtin_cd.c\
	$(SRC_DIR)/builtin_env.c\
	$(SRC_DIR)/builtin_unset.c\
	$(SRC_DIR)/builtin_export.c\
	$(SRC_DIR)/builtin_export_utils.c\
	$(SRC_DIR)/builtin_exit.c\
	$(SRC_DIR)/heredoc.c\
	$(SRC_DIR)/sort_env.c\
	$(SRC_DIR)/exec_other.c\
	$(SRC_DIR)/exec_pipeline.c\
	$(SRC_DIR)/exec_pipeline_utils.c\
	$(SRC_DIR)/shell_level.c\
	$(SRC_DIR)/minishell_clean.c\
	$(SRC_DIR)/minishell_free.c\
	$(SRC_DIR)/test.c\
	$(SRC_DIR)/print_tokenlst.c\
	$(SRC_DIR)/minishell_signals.c\
	$(SRC_DIR)/minishell_signhadle.c\

OBJ = $(SRC:$(SRC_DIR)/%.c=$(OBJ_DIR)/%.o)

#DEP = $(OBJ:.o=.d)

WFLAGS = -Wall -Wextra -Werror

OPT = -g

CC = gcc
#TODO gcc - cc because windows
#-pthread => copile with POSIX threads library

.PHONY: all bonus clean fclean re valgrind

all: $(NAME)

$(NAME): $(OBJ)
	@$(CC) $(WFLAGS) $(LIBFT_FLAGS) $(OPT) $^ $(LIBFT) -lreadline -lncurses -o $@
	@echo "Compilation finished! Executable '$(NAME)' is ready."

libft/libft.a:
	@$(MAKE) -C libft

$(OBJ_DIR)/%.o: $(SRC_DIR)/%.c
	@mkdir -p $(OBJ_DIR)
	@$(CC) $(FLAGS) -c $< -o $@

#-MMD includes all #include dependencies but excludes system headers.

# Include dependencies
#-include $(DEP)

clean:
	@rm -f $(OBJ)
	@rm -rf $(OBJ_DIR)
	@echo "*.o were cleaned."

fclean: clean
	@rm -f $(NAME)
	@echo "Executable '$(NAME)' was removed."

re: fclean all

valgrind:
	valgrind --leak-check=full --show-leak-kinds=all --suppressions=readline.supp --track-fds=yes ./$(NAME)Minishell output:

SRC_DIR = ./src

OBJ_DIR = ./obj

LIBFT = libft/libft.a

LIBFT_FLAGS = -Llibft -lft

	$(SRC_DIR)/print_tokenlst.c\
	$(SRC_DIR)/exec_get_path.c\
	$(SRC_DIR)/exec_get_path_utils.c\
	$(SRC_DIR)/exec_builtin.c\
	$(SRC_DIR)/builtin_pwd.c\
	$(SRC_DIR)/builtin_echo.c\
	$(SRC_DIR)/builtin_cd.c\
	$(SRC_DIR)/builtin_env.c\
	$(SRC_DIR)/builtin_unset.c\
	$(SRC_DIR)/builtin_export.c\
	$(SRC_DIR)/builtin_export_utils.c\
	$(SRC_DIR)/builtin_exit.c\
	$(SRC_DIR)/heredoc.c\
	$(SRC_DIR)/sort_env.c\
	$(SRC_DIR)/exec_other.c\
	$(SRC_DIR)/exec_pipeline.c\
	$(SRC_DIR)/exec_pipeline_utils.c\
	$(SRC_DIR)/test.c\
	$(SRC_DIR)/print_tokenlst.c\

OBJ = $(SRC:$(SRC_DIR)/%.c=$(OBJ_DIR)/%.o)

#DEP = $(OBJ:.o=.d)

WFLAGS = -Wall -Wextra -Werror

OPT = -g

CC = gcc
#TODO gcc - cc because windows
#-pthread => copile with POSIX threads library

.PHONY: all bonus clean fclean re valgrind

all: $(NAME)

$(NAME): $(OBJ)
	@$(CC) $(WFLAGS) $(LIBFT_FLAGS) $(OPT) $^ $(LIBFT) -lreadline -lncurses -o $@
	@echo "Compilation finished! Executable '$(NAME)' is ready."

libft/libft.a:
	@$(MAKE) -C libft

$(OBJ_DIR)/%.o: $(SRC_DIR)/%.c
	@mkdir -p $(OBJ_DIR)
	@$(CC) $(FLAGS) -c $< -o $@

#-MMD includes all #include dependencies but excludes system headers.

# Include dependencies
#-include $(DEP)

clean:
	@rm -f $(OBJ)
	@rm -rf $(OBJ_DIR)
	@echo "*.o were cleaned."

fclean: clean
	@rm -f $(NAME)
	@echo "Executable '$(NAME)' was removed."

re: fclean all

valgrind:

Testing:         cat ./src/minishell_main.c
[31mKO: [0m         cat ./src/minishell_main.c
Bash output:
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   minishell_main.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jrocha-f <jrocha-f@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/02 11:08:25 by macamarg          #+#    #+#             */
/*   Updated: 2025/03/12 11:01:15 by jrocha-f         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

static void	env_cpy(t_minishell *master, char **envp, int i)
{
	t_env	*tmp;
	t_env	*iter;

	while (envp && envp[++i])
	{
		tmp = safe_malloc(sizeof(t_env));
		tmp->env_var = ft_strdup(envp[i]);
		tmp->next = NULL;
		if (master->envp == NULL)
			master->envp = tmp;
		else
		{
			iter = master->envp;
			while (iter->next != NULL)
			{
				iter = iter->next;
			}
			iter->next = tmp;
		}
	}
	if (envp)
		master->env = env_cpy_arr(master->envp, i);
	else
		master->env = NULL;
}

//initi t_minishell
t_minishell	*mini_init(char **argv, char **envp)
{
	t_minishell	*master;

	master = mini_call();
	master->envp = NULL;
	env_cpy(master, envp, -1);
	master->export = NULL;
	sort_env(master, master->env);
	master->argv = argv;
	get_local_directory(master);
	//print_env(master->env);
	master->last_status = 0;
	master->here_status = 0;
	return (master);
}

int	main(int argc, char **argv, char **envp)
{
	t_minishell	*master;

	master = NULL;
	if (argc == 1)
	{
		master = mini_init(argv, envp);
		ft_getprompt(master);
		//ft_clean_ms(master);
	}
	else
	{
		printf("bash: %s: No such file or directory", argv[1]);
		return (EXIT_FAILURE);
	}
	return (EXIT_SUCCESS);
}
Minishell output:
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*                                                    +:+ +:+         +:+     */
/*   By: jrocha-f <jrocha-f@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/02 11:08:25 by macamarg          #+#    #+#             */
/*   Updated: 2025/03/12 11:01:15 by jrocha-f         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */


{
	t_env	*tmp;
	t_env	*iter;

	while (envp && envp[++i])
	{
		tmp = safe_malloc(sizeof(t_env));
		tmp->env_var = ft_strdup(envp[i]);
		tmp->next = NULL;
		if (master->envp == NULL)
			master->envp = tmp;
		else
		{
			iter = master->envp;
			while (iter->next != NULL)
			{
				iter = iter->next;
			}
			iter->next = tmp;
		}
	}
	if (envp)
		master->env = env_cpy_arr(master->envp, i);
	else
		master->env = NULL;
}

{

	master = mini_call();
	master->envp = NULL;
	env_cpy(master, envp, -1);
	master->export = NULL;
	sort_env(master, master->env);
	master->argv = argv;
	get_local_directory(master);
	//print_env(master->env);
	master->last_status = 0;
	master->here_status = 0;
	return (master);
}

int	main(int argc, char **argv, char **envp)
{

	master = NULL;
	if (argc == 1)
	{
		master = mini_init(argv, envp);
		ft_getprompt(master);
		//ft_clean_ms(master);
	}
	else
	{
		printf("bash: %s: No such file or directory", argv[1]);
		return (EXIT_FAILURE);
	}
	return (EXIT_SUCCESS);
}

Testing:     
[32mOK[0m

[1;34m=== Testing export ===[0m

Testing:         export MY_VAR=Hello
[32mOK[0m

Testing:         env | grep MY_VAR
[32mOK[0m

Testing:         export PATH=/new/path
[32mOK[0m

Testing:         env | grep PATH
[32mOK[0m

Testing:     
[32mOK[0m

[1;34m=== Testing exit ===[0m

Testing:         exit
[31mKO: [0m         exit
Bash output:
Minishell output:
exit

Testing:         exit 42
[31mKO: [0m         exit 42
Bash output:
Minishell output:
exit

Testing:     
[32mOK[0m

[1;34m=== Testing Double Quotes ===[0m

Testing:         echo "Hello   World"
[32mOK[0m

Testing:         echo "cat file.txt | grep something"
[32mOK[0m

Testing:     
[32mOK[0m

[1;34m=== Testing Complete ===[0m
You got 16 KO's.
